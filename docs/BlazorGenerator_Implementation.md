# Cadenza BlazorGenerator Implementation

## Overview

The `BlazorGenerator` class is a production-ready implementation that converts Cadenza UI component ASTs into C# classes using Blazor's `RenderTreeBuilder` API. This approach generates type-safe, efficient UI components that integrate seamlessly with the Blazor ecosystem.

## Key Features

### 1. RenderTreeBuilder API Generation
- Generates C# classes that inherit from `ComponentBase`
- Uses `BuildRenderTree(RenderTreeBuilder builder)` method instead of `.razor` files
- Proper sequence number management for efficient Blazor diffing
- Handles complex UI patterns including conditionals and loops

### 2. Production-Ready Code Generation
- Complete C# class structure with proper namespaces
- Type-safe parameter declarations with `[Parameter]` attributes
- Private state fields with automatic `StateHasChanged()` calls
- Service injection through `[Inject]` attributes
- Async/await support for network operations

### 3. Comprehensive Syntax Support

#### Component Declaration
```cadenza
component SimpleCounter(title: string) 
    uses [DOM] 
    state [count, message, disabled]
    events [on_increment, on_decrement, on_reset]
    -> UIComponent 
{
    declare_state count: int = 0
    declare_state message: string = "Click to count"
    
    event_handler handle_increment() uses [DOM] {
        set_state(count, count + 1)
        set_state(message, "Count: " + count.toString())
    }
    
    render {
        div(class: "counter-app") {
            h1(text: title)
            button(text: "+", on_click: handle_increment)
        }
    }
}
```

#### Generated C# Output
```csharp
// <auto-generated>
// This file was generated by the Cadenza compiler. Do not edit manually.

using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
using Microsoft.JSInterop;

public class SimpleCounter : ComponentBase
{
    // Component Parameters
    [Parameter] public string Title { get; set; } = default!;

    // Component State
    private int _count = 0;
    private string _message = "Click to count";

    // Service Injections
    [Inject] private IJSRuntime DOMService { get; set; } = default!;

    // Event Handlers
    private void HandleIncrement()
    {
        _count = _count + 1;
        StateHasChanged();
        _message = $"Count: {_count}";
        StateHasChanged();
    }

    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "class", "counter-app");
        
        builder.OpenElement(2, "h1");
        builder.AddContent(3, Title);
        builder.CloseElement();
        
        builder.OpenElement(4, "button");
        builder.AddAttribute(5, "onclick", EventCallback.Factory.Create(this, HandleIncrement));
        builder.AddContent(6, "+");
        builder.CloseElement();
        
        builder.CloseElement(); // div
    }
}
```

## Implementation Details

### 1. Sequence Number Management
The generator maintains a monotonically increasing sequence number for all RenderTreeBuilder operations:
- Each `OpenElement`, `AddAttribute`, `AddContent` call gets a unique sequence
- Ensures consistent diffing behavior across component updates
- Handles nested components and loops with proper sequence management

### 2. State Management
- Maps Cadenza `declare_state` to private C# fields with `_` prefix
- Generates automatic `StateHasChanged()` calls after state updates
- Supports complex state types and initial values

### 3. Event Handling
- Maps Cadenza event handlers to private C# methods
- Supports both synchronous and asynchronous event handlers
- Automatically detects network operations and generates async methods
- Proper EventCallback generation for Blazor event binding

### 4. Component Composition
- Supports nested component instances
- Handles parameter passing and child content
- Generates proper `OpenComponent`/`CloseComponent` calls
- Manages sequence numbers for component hierarchies

### 5. Conditional and Loop Rendering
- Converts Cadenza `if` statements to C# conditionals in BuildRenderTree
- Handles `foreach` loops with proper region management
- Supports complex conditional expressions and nested structures

## Supported Patterns

### 1. Basic UI Elements
```cadenza
button(text: "Click me", on_click: handle_click, disabled: is_disabled)
```
Generates:
```csharp
builder.OpenElement(0, "button");
builder.AddAttribute(1, "onclick", EventCallback.Factory.Create(this, HandleClick));
builder.AddAttribute(2, "disabled", _isDisabled);
builder.AddContent(3, "Click me");
builder.CloseElement();
```

### 2. Conditional Rendering
```cadenza
if condition {
    p(text: "Condition is true")
}
```
Generates:
```csharp
if (_condition)
{
    builder.OpenElement(4, "p");
    builder.AddContent(5, "Condition is true");
    builder.CloseElement();
}
```

### 3. Loop Rendering
```cadenza
for item in items {
    div(text: item.name)
}
```
Generates:
```csharp
foreach (var item in _items)
{
    builder.OpenRegion(6);
    builder.OpenElement(7, "div");
    builder.AddContent(8, item.Name);
    builder.CloseElement();
    builder.CloseRegion();
}
```

### 4. Component Instances
```cadenza
Button(text: "Save", variant: "primary", on_click: handle_save)
```
Generates:
```csharp
builder.OpenComponent<Button>(9);
builder.AddAttribute(10, "Text", "Save");
builder.AddAttribute(11, "Variant", "primary");
builder.AddAttribute(12, "OnClick", EventCallback.Factory.Create(this, HandleSave));
builder.CloseComponent();
```

## Type Mappings

### Cadenza to C# Types
- `string` → `string`
- `int` → `int`
- `bool` → `bool`
- `List<T>` → `List<T>`
- `Option<T>` → `T?`
- `UIComponent` → `ComponentBase`

### Element Mappings
- `container` → `div`
- `heading` → `h1`
- `text_input` → `input`
- `button` → `button`
- Custom elements pass through unchanged

### Attribute Mappings
- `on_click` → `onclick`
- `on_change` → `onchange`
- `class` → `class`
- `disabled` → `disabled`
- `text` → `value` (for content)

### Effect to Service Mappings
- `DOM` → `IJSRuntime`
- `Network` → `HttpClient`
- `LocalStorage` → `IJSRuntime`
- `Database` → `IDbContext`
- `Logging` → `ILogger`

## Helper Classes

### BlazorGeneratorHelpers
Provides utility methods for:
- Component validation
- CSS class name generation
- Identifier validation
- Type checking
- Lifecycle method mapping

### ValidationResult
Captures validation errors and warnings for component definitions.

### BlazorGenerationOptions
Configures generator behavior:
- CSS class generation
- Async event handler usage
- Documentation comment generation
- Parameter validation

## Integration Points

### 1. Compiler Integration
```csharp
var generator = new BlazorGenerator();
var csharpCode = generator.GenerateBlazorComponent(componentDeclaration);
```

### 2. Build Pipeline
The generator integrates with the Cadenza build pipeline to:
1. Parse `.cdz` files containing UI components
2. Generate corresponding `.g.cs` files
3. Include generated files in the C# compilation

### 3. Development Tools
- LSP integration for IntelliSense support
- Hot reload compatibility
- Debugging support for generated code

## Performance Considerations

### 1. Sequence Number Optimization
- Deterministic sequence number generation
- Efficient diffing for large component trees
- Proper region management for loops

### 2. Memory Management
- StringBuilder reuse for large components
- Minimal object allocation during generation
- Efficient string concatenation patterns

### 3. Generated Code Quality
- Clean, readable C# output
- Proper indentation and formatting
- Minimal runtime overhead

## Testing and Validation

### 1. Unit Tests
- Test individual pattern generation
- Validate sequence number consistency
- Check type mapping accuracy

### 2. Integration Tests
- End-to-end component compilation
- Blazor runtime compatibility
- Performance benchmarks

### 3. Example Validation
- Realistic UI component examples
- Complex interaction patterns
- Production-ready scenarios

## Future Enhancements

### 1. Advanced Features
- CSS-in-JS support
- Animation and transition handling
- WebAssembly optimization
- Server-side rendering support

### 2. Developer Experience
- Better error messages
- Source map generation
- Live preview capabilities
- Visual designer integration

### 3. Performance Optimizations
- Incremental compilation
- Tree shaking for unused components
- Bundle size optimization
- Runtime performance improvements

## Conclusion

The BlazorGenerator provides a robust, production-ready solution for converting Cadenza UI components to efficient Blazor components. It handles the complexity of RenderTreeBuilder API usage while maintaining the declarative, predictable nature of Cadenza syntax. The implementation supports all realistic UI patterns found in modern web applications and generates clean, maintainable C# code that integrates seamlessly with the Blazor ecosystem.