# Cadenza Frontend Compilation Specification (Target: Blazor)

## 1. Introduction

**Current Implementation Status:** This document provides a realistic implementation plan for Cadenza frontend compilation targeting Blazor, based on the current compiler capabilities as of January 2025. Unlike idealized specifications, this focuses on what can be implemented with the existing parser and transpiler infrastructure.

**Core Technology:** Cadenza UI components compile directly to C# classes that inherit from `ComponentBase` and use Blazor's `RenderTreeBuilder` API. This approach provides type-safe, efficient UI rendering while maintaining compatibility with the existing Cadenza compilation pipeline.

**Current Parser Limitations:** The Cadenza parser currently supports basic UI component syntax but has limitations that affect the frontend specification:
- UI elements require function-call syntax: `div()` instead of `div`
- Limited lambda expression support in UI contexts
- Basic expression parsing in attributes
- No type definition parsing for complex UI models

**Implementation Strategy:** This specification defines a **Minimum Viable Product (MVP)** for Blazor support that works with current parser capabilities, with planned enhancements for future releases.

**Key Concept: Sequence Numbers:** Blazor's `BuildRenderTree` method requires unique, monotonically increasing sequence numbers for efficient UI diffing:
*   **Uniqueness:** Each `OpenElement`, `AddContent`, `AddAttribute`, `OpenComponent` call needs a unique sequence number
*   **Consistency:** Sequence numbers must be deterministic across compilations
*   **Dynamic Content:** Loop-generated content requires dynamic sequence number management with explicit keys

## 2. `component` to Blazor Component Class (MVP Implementation)

**Current Parser Support:** The Cadenza parser correctly handles component declarations with the following supported syntax patterns.

**Mapping:** Each Cadenza component with `-> UIComponent` compiles to a C# class inheriting from `ComponentBase`.

**Supported Component Declaration Syntax:**

```cadenza
component ComponentName(param1: Type, param2: Type) 
    uses [Effect1, Effect2] 
    state [stateVar1, stateVar2]
    events [event1, event2]
    -> UIComponent 
{
    declare_state stateVar: type = initialValue
    
    event_handler handle_something() uses [DOM] {
        // handler logic
    }
    
    render {
        // UI elements
    }
}
```

**Current Limitations:**
- Component parameters work with basic types (string, int, bool)
- Effects are parsed but not fully integrated with Blazor services
- State management is basic (no complex state patterns)

**Working Example (SimpleGreeting.cdz):**

```cadenza
component SimpleGreeting(name: string) 
    uses [DOM] 
    state [message]
    events [on_update]
    -> UIComponent 
{
    declare_state message: string = "Hello"
    
    event_handler handle_update() uses [DOM] {
        set_state(message, "Updated!")
    }
    
    render {
        div(class: "greeting") {
            h1(text: message)
            button(text: "Update", on_click: handle_update)
        }
    }
}
```

**Generated C# Target (SimpleGreeting.g.cs):**

```csharp
// <auto-generated>
// This file was generated by the Cadenza compiler. Do not edit manually.

using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;

public class SimpleGreeting : ComponentBase
{
    [Parameter] public string Name { get; set; } = "";
    
    private string _message = "Hello";
    
    private void HandleUpdate()
    {
        _message = "Updated!";
        StateHasChanged();
    }
    
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "class", "greeting");
        
        builder.OpenElement(2, "h1");
        builder.AddContent(3, _message);
        builder.CloseElement();
        
        builder.OpenElement(4, "button");
        builder.AddAttribute(5, "onclick", EventCallback.Factory.Create(this, HandleUpdate));
        builder.AddContent(6, "Update");
        builder.CloseElement();
        
        builder.CloseElement(); // div
    }
}
```

**Explanation:**
*   The `// <auto-generated>` comment is a standard practice for generated code.
*   `using` directives are added for necessary Blazor namespaces.
*   The `Greeting` class inherits `ComponentBase`.
*   `BuildRenderTree` contains the `RenderTreeBuilder` calls. Notice the sequence numbers (0, 1, 2) which are unique for each operation within this method. These numbers help Blazor efficiently update the UI when changes occur.

## 3. State Management (Current Implementation)

**Parser Support:** The Cadenza parser correctly handles `declare_state` declarations and basic `set_state` calls.

**Supported State Syntax:**

```cadenza
component MyComponent -> UIComponent {
    declare_state variableName: type = initialValue
    
    event_handler some_handler() uses [DOM] {
        set_state(variableName, newValue)
    }
}
```

**Current Limitations:**
- State updates use simple assignment syntax: `set_state(variable, value)`
- No complex state update patterns (reducers, computed state)
- Limited type support (basic types work: string, int, bool)
- No state validation or constraints

**Working State Example:**

```cadenza
component Counter -> UIComponent {
    declare_state count: int = 0
    declare_state message: string = "Click to count"
    
    event_handler handle_increment() uses [DOM] {
        set_state(count, count + 1)
        set_state(message, "Count: " + count.toString())
    }
    
    render {
        div(class: "counter") {
            p(text: message)
            button(text: "Increment", on_click: handle_increment)
        }
    }
}
```

**Generated C# Output:**

```csharp
// <auto-generated>
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;

public class Counter : ComponentBase
{
    private int _count = 0;
    private string _message = "Click to count";

    private void HandleIncrement()
    {
        _count = _count + 1;
        _message = "Count: " + _count.ToString();
        StateHasChanged();
    }
    
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "class", "counter");
        
        builder.OpenElement(2, "p");
        builder.AddContent(3, _message);
        builder.CloseElement();
        
        builder.OpenElement(4, "button");
        builder.AddAttribute(5, "onclick", EventCallback.Factory.Create(this, HandleIncrement));
        builder.AddContent(6, "Increment");
        builder.CloseElement();
        
        builder.CloseElement();
    }
}
```

**Key Implementation Notes:**
- Each `declare_state` becomes a private field with underscore prefix
- `set_state(variable, value)` translates to field assignment + `StateHasChanged()`
- State variables are accessed directly in render logic
- Basic type mapping: `int -> int`, `string -> string`, `bool -> bool`

## 4. The `render` Block: Current Implementation

**Parser Support:** The current parser requires UI elements to use function-call syntax with parentheses and explicit attribute declarations.

**Required Syntax (Current Parser):**

```cadenza
render {
    element_name(attribute1: value1, attribute2: value2) {
        // child elements or text
    }
}
```

**Current Limitations:**
- Elements MUST have parentheses: `div()` not `div`
- Text content requires explicit attributes: `text: "content"`  
- No shorthand syntax for text-only elements
- Limited expression support in attributes

### 4.1. HTML Elements (Current Implementation)

**Working Syntax Patterns:**

```cadenza
render {
    div(class: "container") {
        h1(text: "Welcome")
        p(text: "Current count: " + count.toString())
        button(text: "Click me", class: "btn", on_click: handle_click)
    }
}
```

**Generated C# Output:**

```csharp
protected override void BuildRenderTree(RenderTreeBuilder builder)
{
    builder.OpenElement(0, "div");
    builder.AddAttribute(1, "class", "container");
    
    builder.OpenElement(2, "h1");
    builder.AddContent(3, "Welcome");
    builder.CloseElement();
    
    builder.OpenElement(4, "p");
    builder.AddContent(5, $"Current count: {_count.ToString()}");
    builder.CloseElement();
    
    builder.OpenElement(6, "button");
    builder.AddAttribute(7, "class", "btn");
    builder.AddAttribute(8, "onclick", EventCallback.Factory.Create(this, HandleClick));
    builder.AddContent(9, "Click me");
    builder.CloseElement();
    
    builder.CloseElement(); // div
}
```

**Element Mapping:**
- `div()` → `<div>`
- `h1()`, `h2()`, etc. → `<h1>`, `<h2>`
- `button()` → `<button>`
- `p()` → `<p>`
- `span()` → `<span>`
- `input()` → `<input>`

**Explanation:**
*   Each HTML tag (e.g., `div`, `h1`, `p`) results in an `OpenElement` and `CloseElement` pair.
*   Text content within elements is added using `AddContent`.
*   Cadenza expressions within strings (e.g., `${state.count}`) are translated into C# interpolated strings (e.g., `$"Current count is: {this._count}"`). Remember that `state.count` maps to the private field `_count`.
*   The sequence numbers are carefully assigned to maintain uniqueness and consistency.

### 4.2. Attributes and Event Handlers (Current Implementation)

**Supported Attributes:**

| Cadenza Attribute | Maps To | Example |
|-------------------|---------|---------|
| `class` | `class` | `class: "btn-primary"` |
| `id` | `id` | `id: "my-button"` |
| `text` | Content | `text: "Click me"` |
| `disabled` | `disabled` | `disabled: true` |
| `value` | `value` | `value: input_value` |
| `placeholder` | `placeholder` | `placeholder: "Enter text"` |

**Event Handler Mapping:**

| Cadenza Event | Blazor Event | Example |
|---------------|--------------|---------|
| `on_click` | `onclick` | `on_click: handle_click` |
| `on_change` | `onchange` | `on_change: handle_change` |
| `on_input` | `oninput` | `on_input: handle_input` |
| `on_submit` | `onsubmit` | `on_submit: handle_submit` |

**Working Example:**

```cadenza
render {
    button(
        class: "btn-primary",
        disabled: loading,
        text: "Save",
        on_click: handle_save
    )
}
```

**Generated C# Output:**

```csharp
builder.OpenElement(0, "button");
builder.AddAttribute(1, "class", "btn-primary");
builder.AddAttribute(2, "disabled", _loading);
builder.AddAttribute(3, "onclick", EventCallback.Factory.Create(this, HandleSave));
builder.AddContent(4, "Save");
builder.CloseElement();
```

**Current Limitations:**
- Limited to basic attribute types (string, bool, basic expressions)
- No complex expression evaluation in attributes
- Event handlers must be simple method references
- No lambda expressions or inline handlers

**Explanation:**
*   The `class` attribute is straightforwardly mapped.
*   The `onclick: increment` in Cadenza is translated to an `AddAttribute` call for `onclick`, where the value is an `EventCallback` created from the `Increment` C# method (which was generated from the Cadenza `increment` function).

## 5. Control Flow in UI (Current Implementation)

**Parser Support:** The current parser handles basic conditional rendering and iterative rendering within render blocks.

### 5.1. Conditional Rendering

**Supported Syntax:**

```cadenza
render {
    if condition {
        // then elements
    } else {
        // else elements  
    }
}
```

**Current Limitations:**
- Basic boolean conditions only
- No complex logical operators in conditions
- Limited to simple comparisons and state variables

**Working Example:**

```cadenza
component StatusDisplay -> UIComponent {
    declare_state loading: bool = false
    declare_state error: bool = false
    
    render {
        div(class: "status") {
            if loading {
                p(text: "Loading...")
            } else {
                if error {
                    p(text: "Error occurred", class: "error")
                } else {
                    p(text: "Ready", class: "success")
                }
            }
        }
    }
}
```

**Generated C# Output:**

```csharp
protected override void BuildRenderTree(RenderTreeBuilder builder)
{
    builder.OpenElement(0, "div");
    builder.AddAttribute(1, "class", "status");
    
    if (_loading)
    {
        builder.OpenElement(2, "p");
        builder.AddContent(3, "Loading...");
        builder.CloseElement();
    }
    else
    {
        if (_error)
        {
            builder.OpenElement(4, "p");
            builder.AddAttribute(5, "class", "error");
            builder.AddContent(6, "Error occurred");
            builder.CloseElement();
        }
        else
        {
            builder.OpenElement(7, "p");
            builder.AddAttribute(8, "class", "success");
            builder.AddContent(9, "Ready");
            builder.CloseElement();
        }
    }
    
    builder.CloseElement();
}
```

**Explanation:**
*   The Cadenza `if` condition `state.count > 10` is translated to `this._count > 10` in C#.
*   Each branch of the `if/else` contains its own set of `RenderTreeBuilder` calls with their respective sequence numbers. The compiler must ensure these sequence numbers are managed correctly to avoid conflicts and enable efficient UI updates.

### 5.2. List Rendering

**Supported Syntax:**

```cadenza
render {
    for item in collection {
        // render item
    }
}
```

**Current Limitations:**
- Basic collections only (simple types)
- No complex filtering or conditions
- Limited to basic loop patterns

**Working Example:**

```cadenza
component ItemList -> UIComponent {
    declare_state items: List<string> = ["Apple", "Banana", "Cherry"]
    
    render {
        div(class: "item-list") {
            h2(text: "Items:")
            ul() {
                for item in items {
                    li(text: item, key: item)
                }
            }
        }
    }
}
```

**Generated C# Output:**

```csharp
protected override void BuildRenderTree(RenderTreeBuilder builder)
{
    builder.OpenElement(0, "div");
    builder.AddAttribute(1, "class", "item-list");
    
    builder.OpenElement(2, "h2");
    builder.AddContent(3, "Items:");
    builder.CloseElement();
    
    builder.OpenElement(4, "ul");
    
    var sequence = 5;
    foreach (var item in _items)
    {
        builder.OpenElement(sequence++, "li");
        builder.SetKey(item);
        builder.AddContent(sequence++, item);
        builder.CloseElement();
    }
    
    builder.CloseElement(); // ul
    builder.CloseElement(); // div
}
```

**Key Implementation Notes:**
- Each list item requires `builder.SetKey()` for efficient Blazor diffing
- Sequence numbers are generated dynamically within loops
- Simple collections (List&lt;string&gt;, List&lt;int&gt;) are supported
- Complex object iteration requires type definition support (not yet implemented)

**Explanation:**
*   The Cadenza `each` loop is translated into a C# `foreach` loop.
*   A `sequence` variable is introduced and incremented within the loop to ensure unique sequence numbers for each dynamically generated element.
*   `builder.SetKey(item)` is explicitly called for each `<li>` element. This is vital for Blazor's performance when lists change.

## 6. Component Composition (Current Implementation)

**Parser Support:** The current parser handles basic component composition with property passing.

**Supported Syntax:**

```cadenza
render {
    ComponentName(prop1: value1, prop2: value2)
}
```

**Working Example:**

```cadenza
// Child Component (Button.cdz)
component Button(text: string, variant: string) -> UIComponent {
    render {
        button(
            class: "btn btn-" + variant,
            text: text
        )
    }
}

// Parent Component (App.cdz)  
component App -> UIComponent {
    render {
        div(class: "app") {
            h1(text: "My App")
            Button(text: "Save", variant: "primary")
            Button(text: "Cancel", variant: "secondary")
        }
    }
}
```

**Generated C# Output (App.g.cs):**

```csharp
public class App : ComponentBase
{
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "class", "app");
        
        builder.OpenElement(2, "h1");
        builder.AddContent(3, "My App");
        builder.CloseElement();
        
        builder.OpenComponent<Button>(4);
        builder.AddAttribute(5, "Text", "Save");
        builder.AddAttribute(6, "Variant", "primary");
        builder.CloseComponent();
        
        builder.OpenComponent<Button>(7);
        builder.AddAttribute(8, "Text", "Cancel");
        builder.AddAttribute(9, "Variant", "secondary");
        builder.CloseComponent();
        
        builder.CloseElement();
    }
}
```

**Current Limitations:**
- Basic property passing only (primitive types)
- No child content/slot support
- No event callback composition
- Component discovery requires explicit imports

## 7. Implementation Roadmap

### Phase 1: MVP Blazor Support (2-3 weeks)

**Goal:** Get basic UI components compiling to working Blazor C# code.

**Requirements:**
1. **Replace BlazorGenerator.cs** with production RenderTreeBuilder implementation
2. **Integrate with main compilation pipeline** 
   - Add UI component detection in `CadenzaTranspiler`
   - Route `-> UIComponent` components to Blazor generator
3. **Add CLI support** for `--target blazor` flag
4. **Implement sequence number management** for efficient Blazor diffing

**Deliverables:**
- Working Blazor components from simple Cadenza UI syntax
- Basic state management with `StateHasChanged()`
- Event handlers working correctly
- Component parameters and composition

### Phase 2: Parser Enhancements (2-3 weeks)

**Goal:** Improve parser to support more natural UI syntax.

**Requirements:**
1. **Enhanced UI element syntax** - Support elements without parentheses
2. **String interpolation in UI contexts** - Fix template string parsing in attributes
3. **Expression parsing improvements** - Complex expressions in attributes
4. **Type definition support** - Basic `type` declarations for UI models

**Deliverables:**
- More natural syntax: `div { h1 { "text" } }`
- String interpolation working: `h1 { $"Count: {count}" }`
- Conditional expressions: `class: loading ? "loading" : "ready"`

### Phase 3: Development Tooling (2 weeks)

**Goal:** Provide good developer experience for UI development.

**Requirements:**
1. **File watching** for `.cdz` files
2. **Hot reload integration** with Blazor dev server
3. **Error reporting** for UI compilation issues
4. **Project templates** for UI applications

**Deliverables:**
- `cadenzac dev --watch` command
- Live reload when UI components change
- Clear error messages for UI syntax issues
- Project templates: `cadenzac new ui-app`

### Phase 4: Advanced Features (3-4 weeks)

**Goal:** Production-ready UI development capabilities.

**Requirements:**
1. **Lambda expressions** in event handlers
2. **Complex state patterns** (computed state, reducers)
3. **Advanced component patterns** (slots, child content)
4. **CSS integration** (scoped styles, themes)

**Deliverables:**
- Event handlers: `on_click: () => handle_item(item.id)`
- Component slots and child content
- Scoped CSS generation
- Theme system integration

## 8. Current Limitations and Workarounds

### Parser Limitations

**1. UI Element Syntax**
- **Current:** `div(class: "container")` 
- **Desired:** `div { class: "container" }`
- **Workaround:** Use function-call syntax for now

**2. Text Content**
- **Current:** `h1(text: "Hello")`
- **Desired:** `h1 { "Hello" }`
- **Workaround:** Use `text` attribute

**3. String Interpolation**
- **Current:** Limited support in UI contexts
- **Desired:** `h1 { $"Count: {count}" }`
- **Workaround:** Use string concatenation: `"Count: " + count.toString()`

**4. Complex Expressions**
- **Current:** Basic expressions only
- **Desired:** `class: loading ? "loading" : "ready"`
- **Workaround:** Use conditional rendering with separate elements

### Type System Limitations

**1. Type Definitions**
- **Missing:** `type User { name: string, email: string }`
- **Impact:** Complex UI models not supported
- **Workaround:** Use basic types only

**2. List Types**
- **Partially working:** `List<string>` in state
- **Missing:** Complex object lists
- **Workaround:** Simple collections only

### Integration Limitations

**1. Blazor Generator**
- **Status:** Proof-of-concept only
- **Missing:** Production RenderTreeBuilder implementation
- **Workaround:** Manual C# generation for testing

**2. CLI Integration**
- **Missing:** `--target blazor` support
- **Current:** Use `TranspileToBlazorAsync()` method directly
- **Workaround:** Manual compilation for testing

## 9. Next Steps

### Immediate Actions Required

**1. Start with Phase 1 MVP Implementation**
- Focus on getting basic UI components working
- Target simple counter/todo list examples 
- Use current parser limitations as constraints

**2. Create Working Examples**
- Build examples using current supported syntax
- Test end-to-end compilation with existing BlazorGenerator
- Document what actually works vs. what fails

**3. Define Realistic MVP Scope**
- Basic component declaration and rendering
- Simple state management with `StateHasChanged()`
- Event handlers for click events
- Component parameters (primitive types only)
- Basic conditional rendering

### Development Recommendations

**1. Don't Build Aspirational Features**
- Start with what the parser can handle today
- Enhance parser incrementally after MVP works
- Focus on production-ready core features

**2. Test-Driven Implementation**
- Create working `.cdz` examples first
- Verify parser generates correct AST
- Build Blazor generator to match AST structure
- Test generated C# code compiles and runs

**3. Incremental Enhancement Strategy**
- Get MVP working with current syntax
- Identify highest-value parser improvements
- Enhance one language feature at a time
- Maintain backward compatibility

## 10. Conclusion

The Cadenza frontend specifications need significant revision to align with current compiler capabilities. The parser supports basic UI component patterns but lacks advanced features assumed in the original specification.

**Key Takeaways:**
1. **Multi-file project support exists** - prerequisite is met
2. **Basic UI AST nodes are implemented** - foundation is solid
3. **Parser syntax limitations require workarounds** - need realistic examples
4. **BlazorGenerator needs complete rewrite** - current version is demo only
5. **CLI integration missing** - needs `--target blazor` support

**Success depends on:**
- Realistic scope definition matching parser capabilities
- Working examples using supported syntax
- Production-ready RenderTreeBuilder implementation
- Comprehensive testing of generated Blazor components

The frontend vision is achievable but requires focused development effort aligned with current compiler capabilities rather than aspirational language features.
