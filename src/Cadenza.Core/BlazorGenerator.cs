// Cadenza Blazor Generator - Converts Cadenza UI components to Blazor components
// This generator creates C# classes using RenderTreeBuilder API instead of .razor files

using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.Threading.Tasks;
using Cadenza.Core;

namespace Cadenza.Core
{
    /// <summary>
    /// Generates Blazor ComponentBase classes from Cadenza UI component ASTs using RenderTreeBuilder API
    /// </summary>
    public class BlazorGenerator
    {
        private readonly StringBuilder _classContent = new();
        private readonly HashSet<string> _usedNamespaces = new();
        private readonly Dictionary<string, string> _stateVariables = new();
        private readonly List<string> _eventHandlers = new();
        private int _sequenceNumber = 0;
        
        /// <summary>
        /// Generates a Blazor ComponentBase class from a Cadenza ComponentDeclaration
        /// </summary>
        public string GenerateBlazorComponent(ComponentDeclaration component)
        {
            _classContent.Clear();
            _usedNamespaces.Clear();
            _stateVariables.Clear();
            _eventHandlers.Clear();
            _sequenceNumber = 0;

            // Add required namespaces
            AddRequiredNamespaces(component);
            
            // Generate class content
            GenerateComponentClass(component);
            
            // Combine using statements and class
            var result = new StringBuilder();
            result.AppendLine("// <auto-generated>");
            result.AppendLine("// This file was generated by the Cadenza compiler. Do not edit manually.");
            result.AppendLine("// Direct .g.cs generation - explicit over implicit compilation");
            result.AppendLine();
            
            foreach (var ns in _usedNamespaces.OrderBy(n => n))
            {
                result.AppendLine($"using {ns};");
            }
            result.AppendLine();
            
            // Add proper namespace for component discovery (matches assembly name)
            result.AppendLine("namespace CadenzaWebApp.Components.Pages");
            result.AppendLine("{");
            
            // Add indentation to all class content lines
            var indentedClassContent = string.Join("\n", 
                _classContent.ToString().Split('\n')
                    .Select(line => string.IsNullOrWhiteSpace(line) ? line : "    " + line));
            result.Append(indentedClassContent);
            
            result.AppendLine();
            result.AppendLine("}"); // Close namespace
            
            return result.ToString();
        }

        /// <summary>
        /// Adds required namespaces for the component
        /// </summary>
        private void AddRequiredNamespaces(ComponentDeclaration component)
        {
            _usedNamespaces.Add("Microsoft.AspNetCore.Components");
            _usedNamespaces.Add("Microsoft.AspNetCore.Components.Rendering");
            
            if (component.Effects != null)
            {
                foreach (var effect in component.Effects)
                {
                    AddEffectNamespace(effect);
                }
            }
        }
        
        /// <summary>
        /// Generates the complete component class
        /// </summary>
        private void GenerateComponentClass(ComponentDeclaration component)
        {
            // Add RouteAttribute for Blazor Router (equivalent to @page directive)
            // Use proper route format with leading slash
            _classContent.AppendLine($"[Microsoft.AspNetCore.Components.RouteAttribute(\"/{component.Name.ToLower()}\")]");
            _classContent.AppendLine($"public class {component.Name} : ComponentBase");
            _classContent.AppendLine("{");
            
            // Generate parameters
            GenerateParameters(component.Parameters);
            
            // Generate state fields
            GenerateStateFields(component.State);
            
            // Generate service injections
            GenerateServiceInjections(component.Effects);
            
            // Generate lifecycle methods
            GenerateLifecycleMethods(component);
            
            // Generate event handlers
            GenerateEventHandlers(component.Events);
            
            // Generate BuildRenderTree method
            GenerateBuildRenderTreeMethod(component);
            
            _classContent.AppendLine("}");
        }

        /// <summary>
        /// Generates the BuildRenderTree method using RenderTreeBuilder API
        /// </summary>
        private void GenerateBuildRenderTreeMethod(ComponentDeclaration component)
        {
            _classContent.AppendLine();
            _classContent.AppendLine("    protected override void BuildRenderTree(RenderTreeBuilder builder)");
            _classContent.AppendLine("    {");
            
            _sequenceNumber = 0;
            GenerateRenderTreeNodes(component.RenderBlock, "        ");
            
            _classContent.AppendLine("    }");
        }
        
        /// <summary>
        /// Generates RenderTreeBuilder calls for UI nodes
        /// </summary>
        private void GenerateRenderTreeNodes(ASTNode node, string indent)
        {
            switch (node)
            {
                case UIElement element:
                    GenerateElementRenderTree(element, indent);
                    break;
                case ConditionalRender conditional:
                    GenerateConditionalRenderTree(conditional, indent);
                    break;
                case IterativeRender iterative:
                    GenerateIterativeRenderTree(iterative, indent);
                    break;
                case ComponentInstance componentInstance:
                    GenerateComponentInstanceRenderTree(componentInstance, indent);
                    break;
                case RenderBlock block:
                    foreach (var item in block.Items)
                    {
                        GenerateRenderTreeNodes(item, indent);
                    }
                    break;
                default:
                    // Handle other node types like text content
                    if (node is StringLiteral textNode)
                    {
                        _classContent.AppendLine($"{indent}builder.AddContent({_sequenceNumber++}, \"{textNode.Value}\");");
                    }
                    break;
            }
        }

        /// <summary>
        /// Generates RenderTreeBuilder calls for HTML elements
        /// </summary>
        private void GenerateElementRenderTree(UIElement element, string indent)
        {
            var tag = MapCadenzaElementToHtml(element.Tag);
            var elementSeq = _sequenceNumber++;
            
            _classContent.AppendLine($"{indent}builder.OpenElement({elementSeq}, \"{tag}\");");
            
            // Generate attributes FIRST (must come immediately after OpenElement)
            foreach (var attr in element.Attributes)
            {
                if (attr.Name != "text") // Skip text attributes - handle as content later
                {
                    GenerateAttributeRenderTree(attr, indent);
                }
            }
            
            // Generate text content AFTER all attributes
            foreach (var attr in element.Attributes)
            {
                if (attr.Name == "text")
                {
                    GenerateTextContentRenderTree(attr, indent);
                }
            }
            
            // Generate children
            if (element.Children != null && element.Children.Count > 0)
            {
                foreach (var child in element.Children)
                {
                    GenerateRenderTreeNodes(child, indent);
                }
            }
            
            _classContent.AppendLine($"{indent}builder.CloseElement();");
        }

        /// <summary>
        /// Generates RenderTreeBuilder calls for attributes (excludes text content)
        /// </summary>
        private void GenerateAttributeRenderTree(UIAttribute attr, string indent)
        {
            var attrSeq = _sequenceNumber++;
            var attributeName = MapCadenzaAttributeToBlazor(attr.Name);
            
            if (attributeName.StartsWith("on") && !attributeName.StartsWith("on_"))
            {
                // This is an event handler
                var eventHandlerName = GenerateExpression(attr.Value);
                _classContent.AppendLine($"{indent}builder.AddAttribute({attrSeq}, \"{attributeName}\", EventCallback.Factory.Create(this, {eventHandlerName}));");
            }
            else if (attr.Value is StringLiteral stringLiteral)
            {
                _classContent.AppendLine($"{indent}builder.AddAttribute({attrSeq}, \"{attributeName}\", \"{stringLiteral.Value}\");");
            }
            else if (attr.Value is Identifier identifier)
            {
                _classContent.AppendLine($"{indent}builder.AddAttribute({attrSeq}, \"{attributeName}\", {MapStateVariableName(identifier.Name)});");
            }
            else if (attr.Value is BooleanLiteral boolLiteral)
            {
                _classContent.AppendLine($"{indent}builder.AddAttribute({attrSeq}, \"{attributeName}\", {boolLiteral.Value.ToString().ToLower()});");
            }
            else
            {
                var expression = GenerateExpression(attr.Value);
                _classContent.AppendLine($"{indent}builder.AddAttribute({attrSeq}, \"{attributeName}\", {expression});");
            }
        }
        
        /// <summary>
        /// Generates RenderTreeBuilder calls for text content
        /// </summary>
        private void GenerateTextContentRenderTree(UIAttribute attr, string indent)
        {
            var contentSeq = _sequenceNumber++;
            
            if (attr.Value is StringLiteral stringLiteral)
            {
                _classContent.AppendLine($"{indent}builder.AddContent({contentSeq}, \"{stringLiteral.Value}\");");
            }
            else
            {
                var expression = GenerateExpression(attr.Value);
                _classContent.AppendLine($"{indent}builder.AddContent({contentSeq}, {expression});");
            }
        }

        /// <summary>
        /// Generates conditional rendering using RenderTreeBuilder
        /// </summary>
        private void GenerateConditionalRenderTree(ConditionalRender conditional, string indent)
        {
            var condition = GenerateExpression(conditional.Condition);
            
            _classContent.AppendLine($"{indent}if ({condition})");
            _classContent.AppendLine($"{indent}{{");
            
            foreach (var item in conditional.ThenBody)
            {
                GenerateRenderTreeNodes(item, indent + "    ");
            }
            
            _classContent.AppendLine($"{indent}}}");
            
            if (conditional.ElseBody != null && conditional.ElseBody.Count > 0)
            {
                _classContent.AppendLine($"{indent}else");
                _classContent.AppendLine($"{indent}{{");
                
                foreach (var item in conditional.ElseBody)
                {
                    GenerateRenderTreeNodes(item, indent + "    ");
                }
                
                _classContent.AppendLine($"{indent}}}");
            }
        }

        /// <summary>
        /// Generates iterative rendering using RenderTreeBuilder
        /// </summary>
        private void GenerateIterativeRenderTree(IterativeRender iterative, string indent)
        {
            var collectionExpr = GenerateExpression(iterative.Collection);
            
            if (iterative.Condition != null)
            {
                // Use LINQ Where for conditional iteration
                var conditionExpr = GenerateExpression(iterative.Condition);
                _classContent.AppendLine($"{indent}foreach (var {iterative.Variable} in {collectionExpr}.Where({iterative.Variable} => {conditionExpr}))");
            }
            else
            {
                _classContent.AppendLine($"{indent}foreach (var {iterative.Variable} in {collectionExpr})");
            }
            
            _classContent.AppendLine($"{indent}{{");
            
            // Each iteration needs a unique sequence number for proper Blazor diffing
            _classContent.AppendLine($"{indent}    builder.OpenRegion({_sequenceNumber++});");
            
            foreach (var item in iterative.Body)
            {
                GenerateRenderTreeNodes(item, indent + "    ");
            }
            
            _classContent.AppendLine($"{indent}    builder.CloseRegion();");
            _classContent.AppendLine($"{indent}}}");
        }

        /// <summary>
        /// Generates component instance using RenderTreeBuilder
        /// </summary>
        private void GenerateComponentInstanceRenderTree(ComponentInstance instance, string indent)
        {
            var componentSeq = _sequenceNumber++;
            
            _classContent.AppendLine($"{indent}builder.OpenComponent<{instance.Name}>({componentSeq});");
            
            // Generate component parameters
            foreach (var prop in instance.Props)
            {
                var paramSeq = _sequenceNumber++;
                var paramName = prop.Name;
                var paramValue = GenerateExpression(prop.Value);
                
                _classContent.AppendLine($"{indent}builder.AddAttribute({paramSeq}, \"{paramName}\", {paramValue});");
            }
            
            // Handle child content if present
            if (instance.Children != null && instance.Children.Count > 0)
            {
                var childContentSeq = _sequenceNumber++;
                _classContent.AppendLine($"{indent}builder.AddAttribute({childContentSeq}, \"ChildContent\", (RenderFragment)((builder2) => {{");
                
                var oldSequenceNumber = _sequenceNumber;
                _sequenceNumber = 0; // Reset for child content
                
                foreach (var child in instance.Children)
                {
                    GenerateRenderTreeNodes(child, indent + "    ");
                }
                
                _sequenceNumber = oldSequenceNumber; // Restore sequence
                _classContent.AppendLine($"{indent}}}));");
            }
            
            _classContent.AppendLine($"{indent}builder.CloseComponent();");
        }

        /// <summary>
        /// Generates component parameters as [Parameter] properties
        /// </summary>
        private void GenerateParameters(List<Parameter>? parameters)
        {
            if (parameters == null || parameters.Count == 0) return;
            
            _classContent.AppendLine();
            _classContent.AppendLine("    // Component Parameters");
            
            foreach (var param in parameters)
            {
                var blazorType = MapCadenzaTypeToBlazor(param.Type);
                _classContent.AppendLine($"    [Parameter] public {blazorType} {param.Name} {{ get; set; }} = default!;");
            }
        }
        
        /// <summary>
        /// Generates private fields for state variables
        /// </summary>
        private void GenerateStateFields(List<StateDeclaration>? stateDeclarations)
        {
            if (stateDeclarations == null || stateDeclarations.Count == 0) return;
            
            _classContent.AppendLine();
            _classContent.AppendLine("// Component State");
            
            // Use a HashSet to prevent duplicate state variables
            var processedStateNames = new HashSet<string>();
            
            foreach (var state in stateDeclarations)
            {
                if (processedStateNames.Contains(state.Name))
                {
                    Console.WriteLine($"⚠️ Skipping duplicate state variable: {state.Name}");
                    continue;
                }
                processedStateNames.Add(state.Name);
                
                var blazorType = MapCadenzaTypeToBlazor(state.Type);
                _stateVariables[state.Name] = blazorType;
                
                if (state.InitialValue != null)
                {
                    var initialValue = GenerateExpression(state.InitialValue);
                    _classContent.AppendLine($"private {blazorType} _{state.Name} = {initialValue};");
                }
                else
                {
                    _classContent.AppendLine($"private {blazorType} _{state.Name} = default!;");
                }
            }
        }
        
        /// <summary>
        /// Generates service injection properties
        /// </summary>
        private void GenerateServiceInjections(List<string>? effects)
        {
            if (effects == null || effects.Count == 0) return;
            
            _classContent.AppendLine();
            _classContent.AppendLine("    // Service Injections");
            
            foreach (var effect in effects)
            {
                var serviceType = MapEffectToBlazorService(effect);
                _classContent.AppendLine($"    [Inject] private {serviceType} {effect}Service {{ get; set; }} = default!;");
            }
        }

        /// <summary>
        /// Generates lifecycle methods like OnInitializedAsync
        /// </summary>
        private void GenerateLifecycleMethods(ComponentDeclaration component)
        {
            if (component.OnMount != null)
            {
                _classContent.AppendLine();
                _classContent.AppendLine("    // Component Lifecycle");
                _classContent.AppendLine("    protected override async Task OnInitializedAsync()");
                _classContent.AppendLine("    {");
                
                GenerateStatements(component.OnMount, "        ");
                
                _classContent.AppendLine("    }");
            }
        }

        /// <summary>
        /// Generates event handler methods
        /// </summary>
        private void GenerateEventHandlers(List<EventHandler>? eventHandlers)
        {
            if (eventHandlers == null || eventHandlers.Count == 0) return;
            
            _classContent.AppendLine();
            _classContent.AppendLine("    // Event Handlers");
            
            foreach (var handler in eventHandlers)
            {
                var returnType = handler.Effects?.Contains("Network") == true ? "Task" : "void";
                var asyncModifier = returnType == "Task" ? "async " : "";
                
                _classContent.AppendLine($"    private {asyncModifier}{returnType} {handler.Name}()");
                _classContent.AppendLine("    {");
                
                foreach (var statement in handler.Body)
                {
                    GenerateStatements(statement, "        ");
                }
                
                _classContent.AppendLine("    }");
                _classContent.AppendLine();
                
                _eventHandlers.Add(handler.Name);
            }
        }

        /// <summary>
        /// Adds namespace for effect
        /// </summary>
        private void AddEffectNamespace(string effect)
        {
            switch (effect)
            {
                case "Network":
                    _usedNamespaces.Add("System.Net.Http");
                    break;
                case "LocalStorage":
                case "DOM":
                    _usedNamespaces.Add("Microsoft.JSInterop");
                    break;
                case "Database":
                    _usedNamespaces.Add("Microsoft.EntityFrameworkCore");
                    break;
                case "Logging":
                    _usedNamespaces.Add("Microsoft.Extensions.Logging");
                    break;
                default:
                    _usedNamespaces.Add("Cadenza.Services");
                    break;
            }
        }

        /// <summary>
        /// Maps Cadenza element names to HTML tags
        /// </summary>
        private string MapCadenzaElementToHtml(string cadenzaElement)
        {
            return cadenzaElement switch
            {
                "container" => "div",
                "heading" => "h1",
                "button" => "button",
                "text_input" => "input",
                "text" => "span",
                "image" => "img",
                "list" => "ul",
                "list_item" => "li",
                "table" => "table",
                "table_row" => "tr",
                "table_header" => "th",
                "table_cell" => "td",
                "main_content" => "main",
                "card" => "div",
                "form_header" => "div",
                "form_fields" => "div",
                "form_field" => "div",
                "form_actions" => "div",
                _ => cadenzaElement
            };
        }

        /// <summary>
        /// Maps Cadenza attributes to Blazor attributes
        /// </summary>
        private string MapCadenzaAttributeToBlazor(string cadenzaAttribute)
        {
            return cadenzaAttribute switch
            {
                "on_click" => "onclick",
                "on_change" => "onchange",
                "on_input" => "oninput",
                "on_submit" => "onsubmit",
                "on_mouse_enter" => "onmouseenter",
                "on_mouse_leave" => "onmouseleave",
                "on_key_press" => "onkeypress",
                "class" => "class",
                "id" => "id",
                "text" => "value",
                "placeholder" => "placeholder",
                "disabled" => "disabled",
                "src" => "src",
                "alt" => "alt",
                "role" => "role",
                "aria_label" => "aria-label",
                "type" => "type",
                "for" => "for",
                _ => cadenzaAttribute
            };
        }

        /// <summary>
        /// Maps Cadenza types to Blazor/C# types
        /// </summary>
        private string MapCadenzaTypeToBlazor(string cadenzaType)
        {
            return cadenzaType switch
            {
                "string" => "string",
                "int" => "int",
                "bool" => "bool",
                "float" => "float",
                "double" => "double",
                "DateTime" => "DateTime",
                "List<string>" => "List<string>",
                "List<int>" => "List<int>",
                "Option<string>" => "string?",
                "Option<int>" => "int?",
                "UIComponent" => "ComponentBase",
                _ => cadenzaType
            };
        }

        /// <summary>
        /// Maps Cadenza effects to Blazor services
        /// </summary>
        private string MapEffectToBlazorService(string effect)
        {
            return effect switch
            {
                "Network" => "HttpClient",
                "LocalStorage" => "IJSRuntime",
                "Database" => "IDbContext",
                "Logging" => "ILogger",
                "DOM" => "IJSRuntime",
                _ => $"I{effect}Service"
            };
        }

        /// <summary>
        /// Generates C# expression code from Cadenza AST
        /// </summary>
        private string GenerateExpression(ASTNode expression)
        {
            return expression switch
            {
                Identifier id => MapStateVariableName(id.Name),
                StringLiteral str => $"\"{str.Value}\"",
                NumberLiteral num => num.Value.ToString(),
                BooleanLiteral boolean => boolean.Value.ToString().ToLower(),
                BinaryExpression binary => $"({GenerateExpression(binary.Left)} {GetOperatorSymbol(binary.Operator)} {GenerateExpression(binary.Right)})",
                ArithmeticExpression arithmetic => $"({GenerateExpression(arithmetic.Left)} {GetOperatorSymbol(arithmetic.Operator)} {GenerateExpression(arithmetic.Right)})",
                UnaryExpression unary => $"{GetUnaryOperatorSymbol(unary.Operator)}{GenerateExpression(unary.Operand)}",
                CallExpression call => $"{call.Name}({string.Join(", ", call.Arguments.Select(GenerateExpression))})",
                MethodCallExpression methodCall => $"{GenerateExpression(methodCall.Object)}.{FixMethodCasing(methodCall.Method)}({string.Join(", ", methodCall.Arguments.Select(GenerateExpression))})",
                MemberAccessExpression member => $"{GenerateExpression(member.Object)}.{member.Member}",
                TernaryExpression ternary => $"({GenerateExpression(ternary.Condition)} ? {GenerateExpression(ternary.ThenExpr)} : {GenerateExpression(ternary.ElseExpr)})",
                StringInterpolation interpolation => GenerateStringInterpolation(interpolation),
                _ => expression.ToString() ?? ""
            };
        }
        
        /// <summary>
        /// Maps state variable names to their private field names
        /// </summary>
        private string MapStateVariableName(string name)
        {
            return _stateVariables.ContainsKey(name) ? $"_{name}" : name;
        }
        
        /// <summary>
        /// Fixes method name casing for C# conventions
        /// </summary>
        private string FixMethodCasing(string methodName)
        {
            return methodName switch
            {
                "toString" => "ToString",
                "valueOf" => "ValueOf",
                "equals" => "Equals",
                "hashCode" => "GetHashCode",
                _ => methodName
            };
        }
        
        /// <summary>
        /// Generates string interpolation
        /// </summary>
        private string GenerateStringInterpolation(StringInterpolation interpolation)
        {
            var parts = interpolation.Parts.Select(part =>
                part is StringLiteral str ? str.Value : $"{{{GenerateExpression(part)}}}"
            );
            return $"$\"{string.Join("", parts)}\"";
        }

        /// <summary>
        /// Generates statements for code blocks
        /// </summary>
        private void GenerateStatements(ASTNode statement, string indent)
        {
            switch (statement)
            {
                case CallExpression call when call.Name == "set_state":
                    // Handle Cadenza set_state calls
                    if (call.Arguments.Count == 2)
                    {
                        var stateVar = GenerateExpression(call.Arguments[0]);
                        var newValue = GenerateExpression(call.Arguments[1]);
                        _classContent.AppendLine($"{indent}{stateVar} = {newValue};");
                        _classContent.AppendLine($"{indent}StateHasChanged();");
                    }
                    break;
                    
                case CallExpression call:
                    var callExpr = GenerateExpression(call);
                    _classContent.AppendLine($"{indent}{callExpr};");
                    break;
                    
                case IfStatement ifStmt:
                    _classContent.AppendLine($"{indent}if ({GenerateExpression(ifStmt.Condition)})");
                    _classContent.AppendLine($"{indent}{{");
                    foreach (var stmt in ifStmt.ThenBody)
                    {
                        GenerateStatements(stmt, indent + "    ");
                    }
                    _classContent.AppendLine($"{indent}}}");
                    
                    if (ifStmt.ElseBody != null)
                    {
                        _classContent.AppendLine($"{indent}else");
                        _classContent.AppendLine($"{indent}{{");
                        foreach (var stmt in ifStmt.ElseBody)
                        {
                            GenerateStatements(stmt, indent + "    ");
                        }
                        _classContent.AppendLine($"{indent}}}");
                    }
                    break;
                    
                case LetStatement letStmt:
                    var letType = letStmt.Type ?? "var";
                    var letValue = GenerateExpression(letStmt.Expression);
                    _classContent.AppendLine($"{indent}{letType} {letStmt.Name} = {letValue};");
                    break;
                    
                default:
                    // Handle other statement types
                    var exprCode = GenerateExpression(statement);
                    if (!string.IsNullOrEmpty(exprCode))
                    {
                        _classContent.AppendLine($"{indent}{exprCode};");
                    }
                    break;
            }
        }

        /// <summary>
        /// Gets C# operator symbol from Cadenza operator
        /// </summary>
        private string GetOperatorSymbol(string cadenzaOperator)
        {
            return cadenzaOperator switch
            {
                "+" => "+",
                "-" => "-",
                "*" => "*",
                "/" => "/",
                "==" => "==",
                "!=" => "!=",
                ">" => ">",
                "<" => "<",
                ">=" => ">=",
                "<=" => "<=",
                "&&" => "&&",
                "||" => "||",
                _ => cadenzaOperator
            };
        }

        /// <summary>
        /// Gets C# unary operator symbol
        /// </summary>
        private string GetUnaryOperatorSymbol(string cadenzaOperator)
        {
            return cadenzaOperator switch
            {
                "!" => "!",
                "-" => "-",
                "+" => "+",
                _ => cadenzaOperator
            };
        }
    }
}